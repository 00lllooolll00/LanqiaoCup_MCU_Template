C51 COMPILER V9.60.7.0   MAIN                                                              03/29/2025 13:52:34 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Keli5\C51\BIN\C51.EXE ..\User\Src\main.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\User\Inc;..\Driver\I
                    -nc) DEBUG OBJECTEXTEND PRINT(.\Listings\main.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          /**
   2           * @file main.c
   3           * @author ä¹åƒä¹ç™¾ä¹åä¹
   4           * @brief  åŸºäºè¥¿é£å›¢é˜Ÿçš„æ¨¡æ¿ï¼ŒåŠ ä¸Šè‡ªå·±å†™çš„è°ƒåº¦å™¨ï¼Œå›Šæ‹¬äº†è“æ¡¥æ¯å•ç‰‡æœºçš„æ‰€æœ
             -‰å¤–è®¾ï¼Œå¹¶ä¸”ä¸ºæ¯ä¸€ç§å¤–è®¾éƒ½æä¾›äº†å¯¹åº”çš„ä¾‹å­å’Œæ³¨é‡Šã€‚
   5           * @version 0.1
   6           * @date 2025-03-26
   7           * 
   8           * @copyright Copyright (c) 2025
   9           * 
  10           */
  11          /*HEADER*/
  12          #include "main.h"
  13          #include "Task.h"
  14          #include "Periph.h"
  15          #include "TIM.h"
  16          #include "LED.h"
  17          #include "Seg.h"
  18          #include "Key.h"
  19          #include "Delay.h"
  20          #include "iic.h"
  21          #include "onewire.h"
  22          #include "ds1302.h"
  23          #include "Ultrasonic.h"
  24          #include "Serial.h"
  25          
  26          /*Global Variable*/
  27          uint32_t xdata Mysystick = 0; //ç³»ç»Ÿå¿ƒè·³
  28          uint8_t pdata Seg_Buf[8]; //æ•°ç ç®¡æ˜¾ç¤ºç¼“å­˜
  29          uint8_t pdata Seg_Point[8]; //æ•°ç ç®¡å°æ•°ç‚¹æ˜¾ç¤ºç¼“å­˜
  30          uint8_t pdata ucLed[8]; //LEDç¯æ˜¾ç¤ºç¼“å­˜
  31          uint8_t pdata ucRTC[3] = {23, 59, 50}; //æ—¶é—´å‚¨å­˜ æ—¶ã€åˆ†ã€ç§’
  32          float temperature; //æ¸©åº¦
  33          uint8_t RxData[5]; //ä¸²å£æ¥æ”¶åˆ°çš„çš„æ•°æ®
  34          uint16_t Serial_Idle_Cnt; //ä¸²å£ç©ºé—²è®¡æ—¶å™¨
  35          uint8_t index; //æŒ‡ç¤ºå½“å‰æ¥æ”¶åˆ°æ•°æ®çš„ç´¢å¼•
  36          uint8_t Adval1; //ADè½¬æ¢å€¼
  37          uint8_t Adval2; //ADè½¬æ¢å€¼
  38          
  39          /*Function Prototype*/
  40          /**
  41           * @brief æ»¤æ³¢å™¨ ä½¿è¿ç»­å˜åŒ–çš„æ•°æ®æ›´åŠ å¹³æ»‘
  42           * 
  43           * @param dat è¾“å…¥è¿ç»­å˜åŒ–çš„å¾…æµ‹æ•°æ®
  44           * @param index æ»¤æ³¢ç³»æ•° 0-1 è¶Šå¤§æ»¤æ³¢åŠ›åº¦è¶Šå¤§
  45           * @return uint16_t è¿”å›æ»¤æ³¢åçš„å€¼
  46           * 
  47           * @note å¦‚æœéœ€è¦å¯¹floatç±»å‹çš„æ•°æ®è¿›è¡Œæ»¤æ³¢ è¯·é‡å†™æœ¬å‡½æ•° å¦‚ä¸‹æ‰€ç¤º
  48           */
  49          uint16_t Filter_int(uint16_t dat, float index)
  50          {
  51   1          static uint16_t LastData_int = 0;
  52   1          uint16_t temp;
  53   1          if (!LastData_int) LastData_int = dat;
C51 COMPILER V9.60.7.0   MAIN                                                              03/29/2025 13:52:34 PAGE 2   

  54   1          temp = LastData_int * index + dat * (1 - index);
  55   1          LastData_int = temp;
  56   1          return temp;
  57   1      }
  58          
  59          /**
  60           * @brief å¯¹æµ®ç‚¹ç±»å‹ã€è¿ç»­å˜åŒ–çš„æ•°æ®æ»¤æ³¢
  61           * 
  62           * @param dat è¾“å…¥è¿ç»­å˜åŒ–çš„å¾…æµ‹æ•°æ®
  63           * @param index æ»¤æ³¢ç³»æ•° 0-1 è¶Šå¤§æ»¤æ³¢åŠ›åº¦è¶Šå¤§
  64           * @return float è¿”å›æ»¤æ³¢åçš„å€¼
  65           */
  66          float Filter_float(float dat, float index)
  67          {
  68   1          static float LastData_float = 0;
  69   1          float temp;
  70   1          if (!LastData_float) LastData_float = dat;
  71   1          temp = LastData_float * index + dat * (1 - index);
  72   1          LastData_float = temp;
  73   1          return temp;
  74   1      }
  75          
  76          /*Task1 Creation Key*/
  77          void Task_Key(void)
  78          {
  79   1          static uint8_t Key_Val;
  80   1          static uint8_t Key_Down;
  81   1          static uint8_t Key_Up;
  82   1          static uint8_t Key_Old = 0; //è¯¥å€¼åˆå§‹ç»™0 é¿å…è­¦å‘Š
  83   1      
  84   1          Key_Val = Key_Read();
  85   1          Key_Down = Key_Val & (Key_Val ^ Key_Old);
  86   1          Key_Up = ~Key_Val & (Key_Val ^ Key_Old);
  87   1          Key_Old = Key_Val;
  88   1      
  89   1          /*Test*/
  90   1          if (Key_Down == 4)
  91   1          {
  92   2              static bit Test_Flag = 0;
  93   2              Test_Flag ^= 1;
  94   2              memset(ucLed, Test_Flag, 8);
  95   2              memset(Seg_Point, Test_Flag, 8);
  96   2          }
  97   1      }
  98          
  99          /*Task2 Creation Seg Led*/
 100          void Task_Disp(void)
 101          {
 102   1          uint8_t Scan = Mysystick % 8; //æ˜¾ç¤ºæ‰«æå˜é‡ åªåœ¨0â€”â€”7å‘¨æœŸå˜
 103   1      
 104   1          Seg_Disp(Scan, Seg_Buf[Scan], Seg_Point[Scan]); //æ•°ç ç®¡æ˜¾ç¤º
 105   1          LED_Disp(Scan, ucLed[Scan]); //LEDæ˜¾ç¤º
 106   1      }
 107          
 108          /*Task3 Creation NE555*/
 109          void Task_NE555(void)
 110          {
 111   1          static uint16_t Freq = 0; //NE555é¢‘ç‡
 112   1      
 113   1          //æ˜¾ç¤ºæ•°æ®
 114   1          //ä¸ºé¿å…ç¬¬ä¸€æ¬¡æµ‹é‡æ—¶æ²¡æ•°æ®ï¼Œå…ˆåˆå§‹åŒ–ä¸º0ï¼Œå…ˆæ˜¾ç¤ºç¬¬ä¸€æ¬¡å†å¼€å§‹æµ‹é‡
 115   1          Seg_Buf[0] = Freq / 10000 % 10;
C51 COMPILER V9.60.7.0   MAIN                                                              03/29/2025 13:52:34 PAGE 3   

 116   1          Seg_Buf[1] = Freq / 1000 % 10;
 117   1          Seg_Buf[2] = Freq / 100 % 10;
 118   1          Seg_Buf[3] = Freq / 10 % 10;
 119   1          Seg_Buf[4] = Freq % 10;
 120   1      
 121   1          TR0 = 0; //å…³é—­TIM0è®¡æ•°
 122   1          ET1 = 0; //å…³é—­TIM1ä¸­æ–­å…è®¸
 123   1          Freq = TH0 << 8 | TL0; //è·å–é¢‘ç‡
 124   1          TH0 = TL0 = 0; //æ‰‹åŠ¨æ¸…ç©ºè®¡æ•°å€¼
 125   1          ET1 = 1; //æ‰“å¼€TIM1ä¸­æ–­å…è®¸
 126   1          TR0 = 1; //å¼€å¯TIM0è®¡æ•°
 127   1      }
 128          
 129          /*Task4 Creation Buzz Motor Relay*/
 130          void Task_Periph(void)
 131          {
 132   1          static bit Flag_Buzz = 0;
 133   1          static bit Flag_Relay = 1;
 134   1      
 135   1          Periph_Set(BUZZ, Flag_Buzz);
 136   1          Periph_Set(RELAY, Flag_Relay);
 137   1      
 138   1          //500msç¿»è½¬ä¸€æ¬¡ç»§ç”µå™¨å’Œèœ‚é¸£å™¨çš„ç”µå¹³
 139   1          Flag_Buzz ^= 1;
 140   1          Flag_Relay ^= 1;
 141   1      }
 142          
 143          /*Task5 Creation DS1302*/
 144          void Task_RTC(void)
 145          {
 146   1          uint8_t i;
 147   1          RTC_Read(ucRTC);
 148   1          Seg_Buf[2] = Seg_Buf[5] = 11;
 149   1          for (i = 0; i < 3; i++)
 150   1          {
 151   2              Seg_Buf[i * 3] = ucRTC[i] / 10;
 152   2              Seg_Buf[i * 3 + 1] = ucRTC[i] % 10;
 153   2          }
 154   1      }
 155          
 156          /*Task6 Creation DS18B20*/
 157          void Task_Ds18b20(void)
 158          {
 159   1          float temperature_show; //å±•ç¤ºçš„æ¸©åº¦å€¼
 160   1          temperature = Read_temperature(); //è·å–æ¸©åº¦
 161   1          temperature_show = Filter_float(temperature, 0.3); //æ»¤æ³¢
 162   1      
 163   1          //æ•°æ®æ˜¾ç¤º
 164   1          Seg_Point[1] = 1; //æ˜¾ç¤ºå°æ•°ç‚¹
 165   1          Seg_Buf[0] = (uint8_t)(temperature_show * 10) / 100 % 10;
 166   1          Seg_Buf[1] = (uint8_t)(temperature_show * 10) / 10 % 10;
 167   1          Seg_Buf[2] = (uint8_t)(temperature_show * 10) % 10;
 168   1      }
 169          
 170          /*Task7 Creation Ultrasonic*/
 171          void Task_Ul(void)
 172          {
 173   1          static uint8_t distance;
 174   1          static uint8_t distance_Show;
 175   1          distance = Distance_Get(); //è·å–è·ç¦»
 176   1          distance_Show = (uint8_t)Filter_int(distance, 0.2); //æ»¤æ³¢
 177   1      
C51 COMPILER V9.60.7.0   MAIN                                                              03/29/2025 13:52:34 PAGE 4   

 178   1          //æ˜¾ç¤ºè·ç¦»
 179   1          Seg_Buf[0] = distance_Show / 100 % 10;
 180   1          Seg_Buf[1] = distance_Show / 10 % 10;
 181   1          Seg_Buf[2] = distance_Show % 10;
 182   1      }
 183          
 184          /*Task8 Creation Serial*/
 185          void Task_Serial(void)
 186          {
 187   1          static uint8_t psc = 0; //åˆ†é¢‘å™¨ æ¯1så‘é€ä¸€æ¬¡
 188   1      
 189   1          /*æ¨¡æ‹Ÿä¸²å£å‘é€æ•°æ® è¿™é‡Œæ˜¯1sæ‰“å°ä¸€ä¸ªæ•°æ®*/
 190   1          if (++psc == 4)
 191   1          {
 192   2              psc = 0;
 193   2              printf("systime:%d\r\n", (uint16_t)(Mysystick / 1000));
 194   2          }
 195   1      
 196   1          if (Serial_Idle_Cnt > 300) //300msæ²¡æ¥å—åˆ°æ•°æ®å°±ä¼šè§£æä¸€æ¬¡ è¿™é‡Œå¯ä»¥è‡ªè¡Œè°ƒæ•´
 197   1          {
 198   2              /*ä¸²å£è§£ææ“ä½œ*/
 199   2              if (RxData[0] == '1')
 200   2              {
 201   3                  static bit i = 0;
 202   3                  index = 0;
 203   3                  RxData[0] = 0;
 204   3                  memset(ucLed, i, 8);
 205   3                  i ^= 1;
 206   3              }
 207   2          }
 208   1      }
 209          
 210          /*Task9 Creation PCF8591*/
 211          void Task_PCF8591(void)
 212          {
 213   1          uint16_t Adval1_Show; //æ»¤æ³¢åçš„å±•ç¤ºå€¼
 214   1          uint16_t Adval2_Show; //æ»¤æ³¢åçš„å±•ç¤ºå€¼
 215   1      
 216   1          Adval1 = AD_Read(0x41); //ç”µä½å™¨
 217   1          Adval2 = AD_Read(0x43); //å…‰æ•
 218   1      
 219   1          Adval1_Show = Filter_int(Adval1, 0.2); //æ»¤æ³¢
 220   1          Adval2_Show = Filter_int(Adval2, 0.2);
 221   1          /*
 222   1              tips:   å¦‚æœåªè¯»ä¸€ä¸ªADå€¼ 0x41ä¸ºå…‰æ• 0x43ä¸ºç”µä½å™¨
 223   1                      ä½†æ˜¯ç”±äºæœ¬æ¬¡è¯»å–åˆ°çš„æ•°æ®æ˜¯ä¸Šä¸€æ¬¡è½¬æ¢çš„ç»“æœã€‚
 224   1                      æ‰€ä»¥è¿ç»­è¯»æ•°æ®çš„è¯éœ€è¦å°†ä¸¤ä¸ªé€šé“åè½¬ä¸€ä¸‹ã€‚
 225   1          */
 226   1          DA_Write(Adval1); //è¾“å‡ºå¯¹åº”ç”µå‹
 227   1      
 228   1          Seg_Buf[0] = Adval1_Show / 100 % 10;
 229   1          Seg_Buf[1] = Adval1_Show / 10 % 10;
 230   1          Seg_Buf[2] = Adval1_Show % 10;
 231   1      
 232   1          Seg_Buf[5] = Adval2_Show / 100 % 10;
 233   1          Seg_Buf[6] = Adval2_Show / 10 % 10;
 234   1          Seg_Buf[7] = Adval2_Show % 10;
 235   1      }
 236          
 237          /*MAIN*/
 238          void main(void)
 239          {
C51 COMPILER V9.60.7.0   MAIN                                                              03/29/2025 13:52:34 PAGE 5   

 240   1          /*Initialize*/
 241   1          Periph_Init(); //åˆå§‹åŒ–LEDå’Œå¤–è®¾ å°½é‡å°†è¯¥æ¨¡å—æ”¾åˆ°ç¬¬ä¸€ä¸ª
 242   1          while (Read_temperature() > 80); //æ¶ˆé™¤ds18b20é¦–æ¬¡è½¬æ¢ä¸º85çš„æ•°æ®
 243   1          memset(Seg_Point, 0, 8); //åˆå§‹åŒ–æ•°ç ç®¡å°æ•°ç‚¹ç¼“å†²
 244   1          memset(Seg_Buf, 10, 8); //åˆå§‹åŒ–æ•°ç ç®¡ç¼“å†²åŒº
 245   1          memset(ucLed, 0, 8); //åˆå§‹åŒ–LEDç¼“å†²åŒº
 246   1      
 247   1          RTC_Set(ucRTC); //å°†éœ€è¦çš„æ—¶é—´éƒ½å†™å…¥RTCä¸­
 248   1          // Timer0_Init();//åˆå§‹åŒ–TIM0
 249   1          // Uart1_Init();//åˆå§‹åŒ–ä¸²å£1
 250   1          Timer2_Init(); //åˆå§‹åŒ–å¿ƒè·³æ—¶é’Ÿæº
 251   1      
 252   1          /*Task Add*/
 253   1          /*ä»¥ä¸‹ä¸ºå„ä¸ªæ¨¡å—çš„å®ä¾‹å†ç¨‹  å–æ¶ˆæ³¨é‡Šå³å¯è§‚å¯Ÿå¯¹åº”æ¨¡å—çš„ç°è±¡*/
 254   1          // Task_Add(&Task_Key, 10);
 255   1          // Task_Add(&Task_NE555, 1000);
 256   1          // Task_Add(&Task_Periph, 500);
 257   1          // Task_Add(&Task_RTC, 500);
 258   1          // Task_Add(&Task_Ds18b20, 750);
 259   1          // Task_Add(&Task_Ul, 200);
 260   1          // Task_Add(&Task_Serial, 250);
 261   1          // Task_Add(&Task_PCF8591, 200);
 262   1      
 263   1          /*Loop*/
 264   1          while (1)
 265   1          {
 266   2              Task_Start();
 267   2          }
 268   1      }
 269          
 270          /*ISR*/
 271          /*è¿™é‡Œä½¿ç”¨TIM2å®šæ—¶å™¨ä½œä¸ºç³»ç»Ÿå¿ƒè·³æº*/
 272          void Timer2_Isr(void) interrupt 12
 273          {
 274   1          Mysystick++;
 275   1          Serial_Idle_Cnt++;
 276   1          Task_Disp();
 277   1      }
 278          
 279          /*ä¸²å£ä¸­æ–­*/
 280          void Uart1_Isr(void) interrupt 4
 281          {
 282   1          if (RI) //æ£€æµ‹ä¸²å£1æ¥æ”¶ä¸­æ–­
 283   1          {
 284   2              RI = 0; //æ¸…é™¤ä¸²å£1æ¥æ”¶ä¸­æ–­è¯·æ±‚ä½
 285   2      
 286   2              Serial_Idle_Cnt = 0; //æ²¡æœ‰æ¥æ”¶åˆ°æ•°æ®å°±ä¼šä¸€ç›´è‡ªå¢ï¼Œæ¥æ”¶åˆ°æ•°æ®åä¼šä¿æŒ0ï¼Œé€
             -šè¿‡è¿™ç‚¹å¯ä»¥è¾¾åˆ°ç©ºé—²è§£æçš„æ•ˆæœ
 287   2      
 288   2              RxData[index++] = SBUF;
 289   2          }
 290   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1211    ----
   CONSTANT SIZE    =     13    ----
   XDATA SIZE       =      4    ----
   PDATA SIZE       =     27    ----
   DATA SIZE        =     29      27
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      4    ----
C51 COMPILER V9.60.7.0   MAIN                                                              03/29/2025 13:52:34 PAGE 6   

END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
